import streamlit as st

def show_help_page():
    st.title("Справка / Помощь")
    st.markdown("""
**Добро пожаловать в приложение для прогнозирования временных рядов!**

Ниже приводится пошаговая инструкция, а также простые примеры для лучшего понимания.

---

### 1. Загрузка данных
- **Train (обязательно)**: выберите CSV или Excel-файл с историческими данными.  
  - Пример структуры CSV:

  \`\`\`csv
  Date,ID,Target,SalesChannel
  2023-01-01,Store_A,100,Online
  2023-01-02,Store_A,120,Online
  2023-01-01,Store_B,55,Offline
  \`\`\`

  Минимум три колонки: 
  1) Дата (Date), 
  2) Целевая переменная (Target), 
  3) Идентификатор временного ряда (ID).

- **Forecast (необязательно)**: аналогичный формат, но Target может быть пустым или состоять из NaN.

После загрузки Train-файла приложение покажет первые строки, базовую статистику и пропуски.

---

### 2. Настройка столбцов
- **Колонка с датой (Date)**: нужно указать столбец, где лежит дата.
- **Колонка Target**: столбец с числовым значением, которое необходимо прогнозировать.
- **Колонка ID**: строковый или категориальный идентификатор (например, 'Store_A', 'Store_B').
- **Статические признаки (до 3)**: колонки, которые не меняются со временем (например, 'SalesChannel').  
- Опция "Учитывать праздники РФ?" — добавляет бинарную фичу (0/1) с учётом выходных и праздничных дней.

Пример выбора:
1) Дата → `Date`
2) Target → `Target`
3) ID → `ID`
4) Статические признаки → `["SalesChannel"]`

---

### 3. Обработка пропусков
- Выберите способ заполнения пропусков (None, Constant=0, Forward fill, Group mean).
  - **Constant=0**: все NaN в числовых столбцах превращаются в 0.
  - **Forward fill**: вперёд/назад, чтобы заполнить пропуски предыдущими значениями.
  - **Group mean**: усредняет пропуски внутри каждой группы (ID или других столбцов).

Пример: если у вас колонки `Sales`, `Temperature` и есть пропуски в `Temperature`, можно заполнить их средним по каждому магазину (ID).

---

### 4. Частота временного ряда (freq)
- Можно выбрать `auto (угадать)` или указать вручную: D (день), H (час), M (месяц) и т.п.
- Пример: если данные у вас с шагом в 1 день, выберите 'D'.
- Если AutoGluon не может определить частоту автоматически, приложение выдаст предупреждение.

---

### 5. Метрика и модели
- **Метрика**: (MASE, SMAPE, MSE, RMSE и т.д.).
- **Модели AutoGluon**: можно сразу выбрать \`* (все)\` или конкретные модели (AutoARIMA, DeepAR, Transformer и др.).
- **Presets**: (fast_training, medium_quality, high_quality, best_quality) — чем выше качество, тем дольше обучение.
- **prediction_length**: на сколько шагов вперёд делаем прогноз (например, 7 дней).
- **time_limit**: лимит времени на обучение (секунды).
- **mean_only**: если нужна только медиана (одна кривая прогноза без доверительного интервала).

---

### 6. Обучение модели
1. Нажмите кнопку **«Обучить модель»**.
2. Приложение:
   - Заполнит пропуски по выбранному методу.
   - Добавит признак праздников (если нужно).
   - Приведёт данные к формату TimeSeriesDataFrame, учитывая ID, Date, Target.
   - Запустит \`TimeSeriesPredictor.fit()\`.
3. По окончании вы увидите:
   - **Leaderboard** — таблица с моделями и результатами (score_val).
   - **Fit summary** — подробная сводка обучения.

---

### 7. Прогноз
- Нажмите **«Сделать прогноз»**.
- Если загрузили Forecast, то прогноз считается на нём, иначе — на Train (для теста).
- Отобразятся первые строки таблицы с предсказанными значениями (квантили 0.1, 0.5, 0.9 и т.п.).
- Если есть квантили, приложение покажет графики для первых нескольких ID.

Пример (после нажатия «Сделать прогноз»):
\`\`\`
   item_id   timestamp   0.1      0.5      0.9
0  Store_A   2023-03-01  105.2    110.7    120.5
1  Store_A   2023-03-02  103.1    115.2    125.8
...
\`\`\`

---

### 8. Сохранение результатов
- Укажите путь к Excel-файлу (например, `results.xlsx`).
- Нажмите **«Сохранить результаты»**. 
- Приложение сохранит в Excel:
  - TrainData, ForecastData, Leaderboard, Predictions, Статические фичи.

---

### 9. Логи
- Кнопка **«Показать логи»** отобразит содержимое `logs/app.log`.
- Лог-файл содержит информацию об ошибках и основных действиях (загрузка данных, обучение).

---

### 10. Полезные советы
- Если частота (freq) не распознаётся автоматически, укажите её вручную (D, H, M...).
- При работе с большими данными увеличьте \`time_limit\`.
- Проверяйте целостность данных (нет ли строк без дат, нет ли неправильных форматов).

**Успехов в использовании приложения!**


Часто задаваемые вопросы (FAQ)

Ниже собраны основные вопросы, которые могут возникнуть при работе с приложением, и подробные ответы на них.
Q1: «У меня есть 5 магазинов (ID=Shop1..Shop5). Будет ли модель обучаться отдельно на данных каждого магазина или «сольёт» всё вместе?»

A1:
Модель AutoGluon TimeSeriesPredictor умеет работать с мульти-серийными данными. Вы указываете все магазины в одном датасете, и при этом для каждого магазина (уникальный item_id) формируется своя временная серия.

    AutoGluon не игнорирует различия между магазинами.
    Под капотом она может обучать локальные или глобальные модели, но конечный «предиктор» делает прогноз по каждому ID.
    В интерфейсе всё выглядит как одно обучение, но итоговый прогноз отдельный для каждого магазина.

Q2: «Как влияет признак «Учитывать праздники РФ», если в данных отсутствуют записи на праздничные дни?»

A2:

    Функция add_russian_holiday_feature выставляет russian_holiday=1.0 для дат, которые есть в датафрейме и совпадают с праздниками РФ.
    Если в данных нет строки на праздничный день, код не создаёт новую дату. Признак просто не добавляется там, где строки нет.
    Чтобы учесть праздники, которых нет в исходном ряде (например, нет наблюдений в «выходные»), обычно расширяют данные до сплошного календаря (добавляют пропущенные даты), заполняют Target пропуски (0 или NaN), и только потом добавляют russian_holiday.
    Да, это может улучшать качество прогноза, если на праздники спрос ведёт себя иначе.

Q3: «Если у меня есть статические признаки (страна, город), правильно ли, что AutoGluon будет обучать в разрезе магазин+город+страна, а не просто по номеру магазина?»

A3:

    Важна концепция item_id: это ваш основной идентификатор ряда. Обычно ставят Shop_A, Shop_B и т.п.
    «Город» и «страна» идут как статические (доп.) фичи, которые не меняются со временем, но различаются у разных магазинов.
    AutoGluon видит, что у Shop_A (город=Москва, страна=RU), у Shop_B (город=Казань, страна=RU).
    Эти фичи помогают отличать магазины с одинаковым типом, но разным расположением.
    Если у вас два магазина с «одинаковым номером» в разных городах, стоит сделать уникальные item_id (например, Shop_1_Moscow и Shop_1_Kazan).

Q4: «Сначала я выбираю ID=магазин, а потом меняю на ID=город. Прогнозы сильно отличаются. Что правильнее?»

A4:

    Выбирать ID нужно исходя из того, на каком уровне вы хотите получить прогноз.
        Если вам нужен прогноз по каждому магазину, делайте ID=магазин. А город используйте как статический признак.
        Если вас интересует общий прогноз в разрезе города (суммарные продажи по городу), делайте ID=город.
    Эти два подхода действительно дадут разные результаты, потому что при ID=город все магазины внутри одного города будут считаться одной серией и модель не будет различать их поотдельности.
    Нет «единственно правильного» варианта: всё зависит от бизнес-задачи.

Q5: «Почему в прогнозе много столбцов (0.1, 0.2, ..., mean, 0.9)? Как это понимать?»

A5:

    Это квантильные предсказания. Модель даёт не одну точку, а целый спектр значений.
        0.5 или mean можно считать «центральным» прогнозом.
        0.1 / 0.9 показывают нижнюю и верхнюю границы (например, 10% или 90% квантиль).
    Квантиль 0.1 говорит: «С вероятностью 10% реальные продажи будут ниже этой цифры».
    Квантиль 0.9 говорит: «С вероятностью 90% продажи не превысят эту цифру».
    Таким образом, вы получаете распределение, а не одно число, и можете выбирать уровень «запаса» или «риска», исходя из бизнес-задачи.

Пример:
Если в результате прогноз на дату D для Shop_A —

mean = 256, 0.1 = 190, 0.9 = 322

    Среднее/медиана ~ 256
    Нижняя граница (10%) ~ 190
    Верхняя граница (90%) ~ 322
    Модель показывает, что есть некоторый разброс возможных значений.


""")